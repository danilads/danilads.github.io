<!DOCTYPE html> 
<html>
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>MobileList</title>
	<script src="000 - three.min.js"></script>
	<script src="000 - three.interaction.js"></script>
	<style>
			html{ background-color: black; }
			body { margin: 0; }
			canvas { width: 100%!important; height: 100%!important }
      #container {
        position: relative;   /* needed so child elements use this as their base */
      }
      #hud {
        position: absolute;
        left: 5px;
        top: 5px;
        background: rgba(0, 0, 0, 0.5);  /* 50% opaque black */
        color: white;
        padding: .5em;
        font-family: monospace;
        border-radius: .5em;
      }
		</style>
</head>
<body>
<body>
    <div id="container">
        <canvas id="c"></canvas>
        <div id="hud">fps: <span id="fps"></span></div>
    </div>
  <script>	 
            //001 index
            const scene = new THREE.Scene();
            
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.x=5;
            camera.position.z=20;
           
            const renderer = new THREE.WebGLRenderer({
              canvas: document.querySelector('#c'),
              antialias: true,
            });
            renderer.setClearColor(0xffffff);
            renderer.setSize( window.innerWidth, window.innerHeight );
            
            var y=10;
            var x=0;
       
            for(let i=1000;i>0;i--){
             
              window['sp'+i] = new THREE.Mesh(
                new THREE.SphereGeometry( 1, 8, 8 ),
                new THREE.MeshPhongMaterial({ color: 0x41b882 , precision: 'mediump', specular: 0x050505, shininess: 100})
              );
              
              if(i%10===0){
                y-=1;
                x=0;
              }
              window['sp'+i].position.x = x;
              x++;
              window['sp'+i].position.y = y;
              scene.add(window['sp'+i]);
            }
           
    
            

            
            var n = true;
            var animate = function () {
              requestAnimationFrame( animate );
              
              sp1.rotation.x += 5;
              sp1.rotation.y += 5;
              for(let i=1000;i>0;i--){
                window['sp'+i].rotation.x += 5;
                window['sp'+i].rotation.y += 5;
              
              }
              
             
              renderer.render( scene, camera );
            };

            animate();

            // new a interaction, then you can add interaction-event with your free style
            const interaction = new THREE.Interaction(renderer, scene, camera);
            
            
      
            //resizer
            let BaseCamera = 5;
            
            window.addEventListener('resize', onWindowResize, false);

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);

                //меняем модификатор камеры
                if(window.innerHeight>window.innerWidth){
                  camera.position.z = BaseCamera/(window.innerWidth / window.innerHeight);
                }
                else{
                  camera.position.z = BaseCamera;
                }
            }
            //запускаем при старте
            onWindowResize();

            //006 ambient
            var ambient = new THREE.AmbientLight( 0x666666 );
            scene.add( ambient );
            var light = new THREE.PointLight(0xffffff);
            light.position.set(20, 50, 10);
            scene.add(light);


            //007 fps
            const fpsElem = document.querySelector("#fps");

            let then = 0;
            function render(now) {
              now *= 0.001;                          // convert to seconds
              const deltaTime = now - then;          // compute time since last frame
              then = now;                            // remember time for next frame
              const fps = 1 / deltaTime;             // compute frames per second
              fpsElem.textContent = fps.toFixed(1);  // update fps display
              
            
              requestAnimationFrame(render);
            }
            requestAnimationFrame(render);



	</script>
</body>
</html>